# Thread_Concurrency-
자바의 스레드와 동시성에 대한 이론 및 코드
# 💡 프로세스, 스레드, 멀티태스킹 정리

## 🧠 핵심 개념

### 🔹 프로세스 (Process)
- **정의:** 실행 환경과 자원을 제공하는 **컨테이너**
- **특징:** 각각의 프로세스는 독립적인 메모리 공간을 가짐
- **스레드 간의 관계:** 한 프로세스 안에 여러 스레드가 존재하며, **프로세스에 할당된 메모리를 공유 가능**

#### 📘 예시
> **프로세스:** 워드프로세스  
> - **스레드 1:** 문서 자동 저장  
> - **스레드 2:** 문서 편집  
> - **스레드 3:** 맞춤법 검사

---

### 🔹 스레드 (Thread)
- 프로세스 내부에서 **실제 작업을 수행하는 실행 단위**
- 같은 프로세스 내의 스레드들은 **공유 메모리**를 사용하여 효율적인 통신 가능
- 단, **동기화 문제(교착 상태 등)** 에 주의 필요

---

### 🔹 멀티태스킹 (Multitasking)
- CPU가 여러 작업(프로세스)을 **빠르게 번갈아 가며 실행**하는 방식
- 사람 눈에는 여러 작업이 동시에 수행되는 것처럼 보임

---

### 🔹 멀티프로세싱 (Multiprocessing)
- **CPU 코어가 여러 개** 있을 때, 각 코어가 **서로 다른 프로세스나 스레드**를 실제로 동시에 실행하는 방식  
- 진정한 병렬(Parallel) 실행이 가능함

---

## ⚙️ 스케줄링 (Scheduling)

### 🔸 스케줄링 큐 (Scheduling Queue)
- **운영체제 내부**에 존재
- 어떤 순서로 프로세스나 스레드를 CPU에 할당할지 결정
- CPU는 **스케줄 큐에 있는 작업을 순서대로 가져와 실행**

### 🔸 멀티코어 스케줄링
- CPU 코어가 2개 이상이면, 각 코어가 스케줄 큐의 다른 스레드를 **동시에 실행 가능**
- 즉, **물리적으로 병렬 처리**가 이루어짐

---

## 🧩 컨텍스트 스위칭 (Context Switching)
- CPU가 **현재 실행 중인 프로세스(또는 스레드)** 의 상태를 저장하고  
  **다른 프로세스(또는 스레드)** 로 전환하는 과정  
- 스위칭 시에는 레지스터, 스택 포인터 등의 정보를 저장/복원함
- 너무 잦은 스위칭은 **성능 저하**를 초래할 수 있음

---

## ⚡ 정리 요약

| 구분 | 설명 |
|------|------|
| **프로세스(Process)** | 실행 환경과 자원을 가진 컨테이너 |
| **스레드(Thread)** | 프로세스 내 작업 단위, 메모리 공유 가능 |
| **멀티태스킹(Multitasking)** | CPU가 여러 작업을 빠르게 전환 실행 |
| **멀티프로세싱(Multiprocessing)** | 여러 CPU 코어가 동시에 실행 |
| **스케줄링(Scheduling)** | 실행 순서 및 자원 배분 관리 |
| **컨텍스트 스위칭(Context Switching)** | CPU가 작업을 전환하는 과정 |

---

📚 **참고:**  
- *프로세서(Processor)* 는 **물리적인 CPU 하드웨어**  
- *프로세스(Process)* 는 **운영체제 위에서 실행되는 프로그램 단위**

---

### 🔹 컨텍스트 스위칭 (Context Switching)
- **정의:** CPU가 작업(스레드나 프로세스)을 전환할 때 발생하는 비용  
- **원리:** 작업 1의 실행 상태(레지스터, 스택 포인터 등)를 저장하고,  
  작업 2의 상태를 복원하는 과정에서 오버헤드가 발생  
- **결과:** 너무 자주 전환하면 오히려 전체 성능이 저하될 수 있음

#### 📘 예시
> 예를 들어,  
> - `1~5000` 범위 계산 후 `5000~10000` 계산 결과를 합치는 것보다  
> - `1~10000`까지 한 번에 계산하는 것이 더 효율적일 수 있음  
> ➜ 이유: **두 작업을 분리하면 컨텍스트 스위칭 비용이 추가로 발생하기 때문**

---

### 🔹 스레드 작업 유형 (Thread Workload Types)

| 유형 | 설명 | 예시 |
|------|------|------|
| **CPU Bound Task** | CPU 연산 중심의 작업. 연산, 암호화, 이미지 처리 등 | 데이터 압축, 수학 계산 |
| **I/O Bound Task** | 외부 입출력(I/O) 대기 시간이 많은 작업 | DB 조회, 파일 읽기, 네트워크 요청 |

> ⚡ 대부분의 실무 자바 웹 애플리케이션은 **I/O Bound 작업**이 훨씬 많습니다.  
> 예: 사용자의 입력을 기다리거나, DB에서 데이터를 불러오는 과정 등

---

### 🔹 자바 웹 애플리케이션과 스레드 구조

- 일반적인 자바 웹 서버는 **사용자 요청 1개당 1개의 스레드**가 사용됨  
- 동시에 4명의 사용자가 요청을 보내면, 서버는 **4개의 스레드**를 생성하여 병렬로 처리

```text
사용자 1 요청 → Thread-1  
사용자 2 요청 → Thread-2  
사용자 3 요청 → Thread-3  
사용자 4 요청 → Thread-4

# 🧠 자바 메모리 구조 (Java Memory Structure)

스레드를 제대로 이해하려면 **자바 메모리 구조**를 완벽히 알고 있어야 한다.  
자바 프로그램은 실행 시 다음과 같은 메모리 영역으로 나뉜다.

---

## 1️⃣ 메서드(Method) 영역

- 프로그램 실행에 필요한 **공통 데이터**를 관리한다.  
- **모든 스레드에서 공유**된다.  
- 주요 내용:
  - 클래스 정보(바이트 코드)
  - 필드, 메서드, 생성자 등의 코드
  - **Static 영역** : `static` 변수들이 저장된다.
  - **런타임 상수 풀(Runtime Constant Pool)** : 프로그램 실행 중 필요한 **공통 리터럴 상수**를 저장한다.

---

## 2️⃣ 스택(Stack) 영역

- **자바 프로그램 실행 시 각 스레드마다 하나의 실행 스택이 생성**된다.  
- 하나의 스택 안에는 여러 **스택 프레임(Stack Frame)** 이 쌓이며, 각 프레임은 다음을 포함한다:
  - 지역 변수 (Local Variables)
  - 중간 연산 결과
  - 메서드 호출 정보 (Call Information)

> ⚙️ 참고  
> 스택 영역은 **스레드별로 독립적**이다.  
> 스레드가 1개면 스택도 1개, 스레드가 늘어나면 **스택도 스레드 수만큼 증가**한다.

---

## 3️⃣ 힙(Heap) 영역

- **객체(Object)** 와 **배열(Array)** 이 생성되는 공간이다.  
- 모든 스레드가 **공유**한다.  
- 참조되지 않는 객체는 **GC(Garbage Collector)** 에 의해 자동으로 제거된다.

---

## 📋 정리

| 메모리 영역 | 주요 역할 | 스레드와의 관계 |
|--------------|------------|----------------|
| **메서드 영역** | 클래스 정보, static 변수, 상수 관리 | 모든 스레드가 공유 |
| **스택 영역** | 메서드 실행, 지역 변수 관리 | 스레드별로 독립 생성 |
| **힙 영역** | 객체, 배열 저장 | 모든 스레드가 공유 |

---

> 🧩 **참고:**  
> 스택은 스레드 수만큼 생성되고, 힙과 메서드 영역은 모든 스레드가 공유한다.

---

# Java 스레드(Thread) 개념 정리

## 1. 스레드 실행 특징
- 스레드 간의 **실행 순서**는 예측할 수 없음.
- CPU 코어가 2개 이상이면 **물리적으로 동시에 실행**될 수도 있고,  
  하나의 CPU 코어에서는 **시간을 나누어 번갈아 실행**될 수 있음.
- 한 스레드가 얼마나 오래 실행될지도 보장되지 않음.
- 따라서, 스레드는 **순서와 실행 기간을 모두 보장하지 않는다.**  
  이것이 바로 **멀티스레드의 특징**이다.

---

## 2. `start()`와 `run()`
- `start()` 메서드는 **스레드에 스택 공간을 할당**하고 스레드를 시작하는 특별한 메서드임.
- `start()`를 호출하면 **별도의 스레드에서 `run()` 메서드가 실행됨**.
- `main` 스레드가 아닌 다른 스레드에서 `run()`을 실행하려면 반드시 `start()` 호출 필요.

---

## 3. 스레드 종류
### 3.1 사용자 스레드(User Thread)
- 프로그램의 **주요 작업 수행**
- 작업 완료될 때까지 실행됨
- **모든 사용자 스레드가 종료**되면 JVM도 종료

### 3.2 데몬 스레드(Daemon Thread)
- **백그라운드에서 보조 작업 수행**
- 모든 사용자 스레드가 종료되면 **자동 종료**

---

## 4. 스레드 생성 방법
1. **Thread 클래스를 상속받는 방법**
2. **Runnable 인터페이스 구현 방법**  
   (실무에서는 거의 Runnable을 구현하여 사용)

### 4.1 Thread 클래스 사용
- 장점: `Thread` 클래스를 상속받아 `run()`만 재정의하면 됨  
- 단점: **상속의 제한**, 유연성 부족

### 4.2 Runnable 인터페이스 사용
- 장점: **상속의 자유**, 코드 분리, 여러 스레드가 **Runnable 객체 공유 가능**
- 단점: 약간 복잡, Runnable 객체를 생성하고 Thread에 전달해야 함

**결론:**  
> Thread 클래스를 상속받기보다는 **Runnable 인터페이스를 구현하여 사용하는 것이 실무에서 권장됨**

